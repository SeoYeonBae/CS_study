# :pushpin: 캐시 메모리 (Cache Memory)

### 1. 개요
  - 속도가 느린 장치와 빠른 장치의 **병목 현상**을 줄이기 위한 메모리
   - 병목 현상이란?
     - 전체 시스템의 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상
     - 컴퓨터에서의 병목현상이란 시스템 내 데이터의 집중적인 사용으로 인해, 전체 시스템에 절대적 영향을 미치는 부분의 사용 빈도가 늘어나 그 부분의 성능이 저하되어 전체 시스템이 마비되는 현상
   - 병목 현상의 원인
     - CPU는 데이터를 처리하기 위해 메모리와 끊임없이 데이터를 주고 받음 
     - 이때 CPU에 비해 메모리의 속도가 느려 메모리에 접근할 때 CPU가 효율적으로 사용되지 못함   
     
---

### 2. 캐시 메모리의 사용 예시
  - 웹 브라우저의 캐시 파일: 하드디스크와 웹페이지 사이의 병목 현상을 완화
  - CPU는 원래 주기억 장치에 저장된 데이터를 읽어옴 -> 자주 사용하는 데이터를 주기억장치가 아닌 캐시에 저장 -> 다음에 이용할 때 캐시에서 먼저 가져옴 -> 속도 향상
  - 속도라는 장점은 얻지만 용량이 작고 비용이 비쌈

---

### 3. 캐시 메모리의 분류
  - CPU는 캐시 메모리를 2~3개 사용
  - L1, L2, L3 캐시 메모리라 부르고 속도와 크기에 따라 분류
  - L1 -> L2 -> L3 순으로 접근
    - L1 : CPU 내부에 존재
    - L2 : CPU와 RAM(주기억장치) 사이에 존재
    - L3 : 보통 메인 보드에 존재(있을 수도 있고 없을 수도 있음)
  - 디스크 캐시 : RAM과 하드디스크(보조기억장치) 사이에 존재하는 캐시
  - 참고 : 듀얼 코어에서는 각 코어마다 L1을 갖고 L2를 공유함

---

### 4. 캐시 메모리 작동 원리
- 원리를 이해하기 위해 알아야 하는 지역성
  1. ##### 시간 지역성
     - 반복문에 사용하는 조건 변수 처럼 잠시후에 참조될 가능성이 높음
  2. ##### 공간 지역성
     - 배열의 연속 접근처럼 참조한 데이터 근처에 있는 데이터가 잠시후에 참조될 가능성이 높음

- 캐시에 데이터를 저장할 때 참조 지역성을 최대한 활용하기 위해 해당 데이터뿐만 아니라 옆 주소의 데이터도 미리 가져와 미래를 대비함

---

### 5. 캐시 미스의 3가지

1. ##### Cold miss

   해당 메모리 주소를 처음 불러서 나는 미스

2. ##### Conflict miss

   캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스
   즉, 주소 할당 문제

3. ##### Capacity miss
   캐시 메모리의 공간이 부족해서 나는 미스
   즉, 공간 문제

- 참고 : Capacity는 공간이 없는 것, Conflict는 공간을 잘못 준 것

---

### 6. 캐시의 구조와 작동 방식

1. ##### Direct Mapped Cache

![image](https://user-images.githubusercontent.com/101535851/197096124-7aee2902-4748-448c-8199-aa64e8ad8773.png)
   
   - 가장 기본적인 구조
   - DRAM의 여러 주소가 캐시 메모리 한 주소에 대응되는 다대일 방식
   
   - 캐시 메모리는 인덱스 필드 + 태그 필드 + 데이터 필드로 구성
     - 00**101**, 01**101**, 10**101**, 11**101**인 메모리 주소는 캐시 메모리의 101에 매핑
     - 여기서 **101**이 인덱스 필드
     - 00, 01, 10, 11이 태그 필드
     - 이 두가지 뒤에 데이터를 저장하는 곳이 데이터 필드
     
   - 동작 방법
     - 캐시 메모리 비어있음
     - CPU는 캐시 메모리 먼저 탐색
     - 비어있으니까 메인 메모리 직접 읽어옴
     - 캐시 메모리에 해당 메모리 저장해둠
     - 다음에 같은 데이터 요청하면 캐시 메모리에서 가져옴
     
   - 장점
     - 간단하고 빠름
     
   - 단점
     - Conflict miss

2. ##### Fully Associative Cache
   
   - 비어잇으면 마음대로 주소 저장
   - 저장은 간단하지만 찾을 때 문제
   - 조건이나 규칙이 없어서 특정 캐시 Set 안에 있는 모든 블럭을 한 번에 찾아 원하는 데이터 검색

3. ##### Set Associative Cache
![image](https://user-images.githubusercontent.com/101535851/197100838-c27e753c-ad5b-40f2-99b2-47f8d399ad18.png)
   - Direct + fully
   - 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식
   - Direct에 비해 검색 속도는 느리지만 저장이 빠름
   - Fully에 비해 저장이 느린 대신 검색이 빠른 중간형

---

참고
- [CPU 캐시의 원리](https://ezbeat.tistory.com/455)
- [CPU 캐시 이해하기](https://aidanbae.github.io/code/devops/computer/cpucache/)
- [캐시가 동작하는 아주 구체적인 원리](https://parksb.github.io/article/29.html)
- [CPU의 캐시 메모리](https://macaron85.tistory.com/entry/CPU%EC%9D%98-%EC%BA%90%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-cache-memory)
- [캐시 메모리]https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html
