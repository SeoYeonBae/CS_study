## 📌 저장 프로시저(stored PROCEDURE)

 - 쿼리문들의 집합으로, 어떤 동작을 여러 쿼리를 거쳐서 일괄적으로 처리할 때 사용한다.
 - DB에 대한 작업을 정리한 절차를 RDBMS(관계형 데이터 베이스 관리 시스템)에 저장한 쿼리의 집합
 - 자주 사용되는 일반적인 쿼리를 모듈화시켜서 필요할 때마다 호출
 - 영구 저장 모듈 (Persistent Storage Module)

            
 ```SQL
 CREATE OR REPLACE PROCEDURE 프로시저명(변수명1 IN 데이터타입, 변수명2 OUT 데이터타입) -- 인자 값은 필수 아님
IS
[
  변수명1 데이터타입;
  변수명2 데이터타입;
..
]
BEGIN
  필요한 기능; -- 인자값 활용 가능
END;
---- 저장 프로시저 구성 코드

EXEC 프로시저명; -- 호출
CALL 프로시저명; -- 호출
```


## 1️⃣ 일반 SQL 문과의 차이는 ❓
           
#### 일반 SQL 동작 방식

![image](https://user-images.githubusercontent.com/63505110/217261362-eca15785-7733-45f0-b7c3-fad30c71aef6.png)
- 구문 분석
  - 구문 자체 오류 분석, 오류 발생시 에러 메시지
- 개체 이름 확인
  - 개체(ex. 테이블) 데이터베이스에 존재하는지 확인
- 사용 권한 확인
  - 접근하는 사용자의 권한 확인
- 최적화
  - 가장 좋은 성능을 낼 수 있는 경로 결정
- 컴파일 및 실행계획 등록
  - 최적화된 결과를 바탕으로 해당 실행결과를 메모리(캐시)에 등록
- 실행
  - 컴파일된 결과 실행         

        
#### 동일한 SQL문 실행할 경우
![image](https://user-images.githubusercontent.com/63505110/217261561-8aecfe6f-11c8-4022-a353-5ecb63c371e4.png)
- 과정이 생략되어 시간 단축
- 메모리(캐시)에 동일한 SQL 쿼리 없다면 위의 전체 과정 다시 반복하지만 
- 주의할 점은 쿼리 전체가 한 글자도 틀리지 않고 같아야 한다

#### 저장 프로시저 동작 방식

![image](https://user-images.githubusercontent.com/63505110/217261821-ad2c4e05-a9e3-48ad-9053-c352d979f498.png)

- 구문 분석
  - 구문 오류 확인
- 지연된 이름 확인 (deferred name resolution)
  - 개체(ex. 테이블) 존재 여부와 상관없이 프로시저 정의 가능
  - 개체의 존재 여부를 ***프로시저 실행 시점*** 에 확인
  - 하지만 테이블의 열 이름 틀리면 오류 발생
- 생성 권한 확인
  - 사용자가 저장 프로시저 생성할 권한 있는지 확인 
- 시스템 테이블에 등록
  - 저장 프로시저 명과 코드가 관련 시스템 테이블에 등록됨

#### 저장 프로시저 실행 첫번쨰

![image](https://user-images.githubusercontent.com/63505110/217262892-bb324d9a-b170-49ad-887b-72659f1ea92c.png)

- 위의 프로시저 정의 단계에서 구문 분석 했기에 따로 구문 분석 진행하지 않음
- 개체 이름 확인
  - 지연된 이름 확인(deferred name resolution)에 의해 해당 개체가 유효한지 개체 이름 확인 단계에서 진행

#### 그 이후 저장 프로시저 실행
![image](https://user-images.githubusercontent.com/63505110/217263539-8efaf436-0989-48d2-ad05-be60ad005831.png)

- 메모리(캐시)에 있는 것을 가져와 재사용하여 수행시간 단축


## 2️⃣ 저장 프로시저의 장점은 ❓
### SQL Server 성능 향상
- 저장 프로시저 최초 실행시 최적화 상태로 컴파일된다.
- 저장 프로시저의 두번째 실행부터는 메모리(캐시)에 있는 것을 가져와서 사용하기에 속도가 빠르며 여러 개의 쿼리를 한 번에 실행할 수 있다.

### 유지보수 및 재활용 측면
- C#, JAVA 등으로 만들어진 응용 프로그램에서 직접 SQL문을 호출하지 않고 저장 프로시저의 이름을 호출하도록 설정하여 사용하는 경우 많다.
- 이때 수정이 필요할 때 코드 내부의 SQL문을 수정하는 것이 아닌 SP(stored PROCEDURE) 파일만 수정하면 되기에 유지보수 측면에서 유리하다.
- 한 번 저장 프로시저를 생성하면 언제든 실행이 가능하기 떄문에 재활용 측면에서 뛰어나다.

### 보안 강화 - 권한 체계
- 사용자별로 테이블에 권한을 부여하는 것이 아닌 저장 프로시저에만 접근 권한을 허용한다.
- 테이블의 모든 정보를 사용자에게 노출하지 않고 프로시저에서 선택한 정보만 사용자에게 보여줄 수 있다.

### 네트워크 부하(전송량) 감소
- 쿼리의 모든 텍스트가 클라이언트에서 서버로 전송될 경우 네트워크 부하 커질 수 있다.
- 하지만 저장 프로시저를 사용한다면 서버에 이미 저장되어 있기 때문에 저장 프로시저 명에 매개변수 등 몇 글자만 전송하면 된다.

               
## 2️⃣ 저장 프로시저의 단점은 ❓


### DB 확장 어려움

- 서비스 사용자가 증가하여 서버의 수를 늘려야할 때 DB의 수를 늘리는 것이 어렵다
- DB 교체는 거의 불가능

### 데이터 분석 어려움
- 배포, 버전 관리 등에 대한 이력 관리가 힘들다.
- 디버깅 어려움

### 낮은 처리 성능
- 문자, 숫자열 연산에서 C, JAVA보다 성능이 느리다.

### 🐬 트리거

- 저장 프로시저로 실행할 수 없는 사항을 해결해주는 것으로 테이블이 INSERT, UPDATE, DELETE 될 때 발생하는 이벤트
- 문법은 프로시저와 비슷
- 트리거의 주된 역할은 데이터의 무결성 유지
- 저장 프로시저와의 차이점은 수동으로 실행될 수 없는 자동 실행이라는 점


##### 참고
https://devkingdom.tistory.com/323
https://siahn95.tistory.com/64
