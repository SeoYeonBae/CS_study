## 📌 1. TLS & SSL HandShake

### ✔ TLS & SSL
- TLS : Transport Layer Security
- SSL : Secure Sockets Layer
- 용도
  -  서버와 클라이언트의 인증을 하는데 사용
  -  주로 전송계층과 응용계층 사이에서 보안조치를 하는데 사용
  -  우리들이 많이 접하게 되는 HTTPS://는 SSL을 사용하는 경우를 의미
  -  최근 명칭은 TLS이고 과거 명칭은 SSL
  -  즉, 둘은 같은 것

### ✔ HandShake
- 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름


## 🤝 2. SSL 방식을 자세히 알아보자!

> SSL은 대칭키와 비대칭키를 섞어서 사용함

1. A가 B로 접속 요청을 보내고 B는 A에게 자신의 공개키를 전송

![image](https://user-images.githubusercontent.com/101535851/221473040-de8e5238-58ea-458e-aa7a-08b47bbf1237.png)


2. A는 자신의 대칭 키를 B에서 전달 받은 B의 공개 키로 암호화

![image](https://user-images.githubusercontent.com/101535851/221473086-e85c7cae-f95c-4858-9ee6-19a5b0a74ab1.png)

3. 이렇게 암호화한 대칭키를 B에 전달하고 B는 자신의 개인 키로 복호화하여 A의 대칭키를 얻어냄

![image](https://user-images.githubusercontent.com/101535851/221473403-a19e8266-e1d6-4f2d-9c84-f0df74c0cc8b.png)

4. 상기 과정을 통해 얻어낸 대칭키를 활용하여 A와 B는 안전하게 통신함

![image](https://user-images.githubusercontent.com/101535851/221473467-d10acbe0-c6bd-408a-8f86-bcb9c5fcc519.png)


## 🤝 3. SSL HandShake의 동작 과정

![image](https://user-images.githubusercontent.com/101535851/221474141-7a21913a-67fc-4e3d-9665-a643a9d5d4be.png)

1. "client hello"

  - 클라이언트는 서버에게 "client hello" 메시지를 담아 서버로 보냄
  - 이때 암호화된 정보(버전, 암호 알고리즘, 압축 방식, ...)등을 담아 보냄

2. "server hello"

  - 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받음
  - 이를 세션 ID와 CA 공개 인증서, server hello 메시지와 함께 담아 응답
  - CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있음

3. CA 인증서 유효성 확인

  - 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한지 CA 목록에서 환인하는 과정 진행

4. 서버의 공개키를 통한 암호화

  - CA 인증서에 대한  신뢰성이 확보된 상황이라면
  - 클라이언트는 난수 바이트를 생성해 서버의 공개키로 암호화
  - 이 난수 바이트는 대칭키를 정하는데 사용이 되고 앞으로 서로 메시지를 통신할 때 암호화하는데 사용

5. 추가 정보 전송

   - 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구한 상황이라면
   - 클라이언트의 인증서 + 클라이언트의 개인키로 암호화된 임이의 바이트 문자열을 함께 전송


6. 클라이언트 대칭 마스터 키 생성

   - 서버는 클라이언트의 인증서를 확인
   - 난수 바이트를 자신의 개인키로 복호화하여 대칭 마스터 키 생성

7. "client finished"

  -  클라이언트는 handshake 과정이 완료되었다는 "finished" 메시지를 서버에 보냄
  -  지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보냄

8.  "server finished"

  - 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는지 확인
  - 일치한다면 서버도 "finished" 메시지를 이번에 만든 대칭키로 암호화하여 보냄

9. exchange message

  - 클라이언트는 해당 메시지를 대칭키로 복호화
  - 서로 통신이 가능한 신뢰받은 사용자란 걸 인지
  - 앞으로 클라이언트는 서버와 해당 대칭키로 데이터를 주고받을 수 있게 됨

## 📃 4. CA(Certificate Authority)

- 인증서의 역할 : 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 것
- 이 일을 해주는 민간  기업이 있는데 이를 CA라고 함
- 개발자 입장에서 HTTPS를 적용하려면 신뢰할 수 있는 CA 기업의 인증서를 구입해야 함
- 이를 구입하면 CA 기업의 개인키를 이용항 암호화한 인증서를 줌


## 📃 5. SSL 인증서

- 인증서를 발급한 CA, 서비스의 도메인등과 같은 서비스의 정보와 서버 측 공개 키가 들어있음
- 서버에는 본인의 개인키가 있고, 클라이언트가 사용할 공개키는 인증서 안에 있는 상황 -> 클라이언트는 CA의 개인키로 암호화된 인증서를 어떻게 복호화할까?
- 우리가 사용하는 브라우저에 CA 기관 리스트와 해당 기관의 공개키가담겨 있음!
- 따라서 내장된 CA의 공개키를 활용해 인증서를 복호화함으로써 인증서를 검증한 뒤 서버의 공개키를 가져옴

---

##### 참고

- [SSL 방식, CA와 인증서](https://gyoogle.dev/blog/computer-science/network/TLS%20HandShake.html)
- [TLS/SSL HandShake에 대해 자세히 나와있음](https://steady-coding.tistory.com/512)
- [TLS와 SSL의 개요를 더 자세히 보고 싶다면](https://hanjungv.github.io/2017-11-07-1_CS_SSL/)

