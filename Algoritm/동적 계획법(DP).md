# 📌 동적 계획법(DP)

> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법

- Dynamic Progamming
- 한 가지 문제에 대해서 단 한 번만 풀도록 만들어주는 알고리즘
- 즉, 똑같은 연산을 반복하지 않도록 만들어줌
- 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘
- 답을 구하기 위해 이미 했던 계산을 반복하는 구조인 Optimal Substructure 문제에서 효과를 발휘함

## 🐌 1. 접근 방식

- 커다란 문제를 해결하기 위해 작게 쪼게서 해결하는 방법인 분할정복과 매우 유사
- 하지만, **간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점**이 존재
- 즉, DP는 간단한 문제들 속에서 **계속 반복되는 연산**을 빠르게 풀 수 있는 것이 핵심

## 🐌 2. 조건

1. 작은 문제에서 반복이 일어남
2. 같은 문제는 항상 정답이 같음

- 이 두가지 조건이 충족할 때 DP를 이용하여 문제를 해결할 수 있음
- 두 조건을 활용해 메모이제이션으로 큰 문제를 해결해나가는 것!

## 📝 3. 메모이제이션(Memoization)

- 한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식

### 대표적인 예시 - 피보나치 수열

- 피보나치 수열에서 재귀를 활용해 풀 경우 같은 연산을 반복함을 알 수 있음
- 이때, 메모이제이션을 통해 같은 작업을 되풀이하지 않도록 구현하면 효율적

```
fibonacci(5) = fibonacci(4) + fibonacci(3)
fibonacci(4) = fibonacci(3) + fibonacci(2)
fibonacci(3) = fibonacci(2) + fibonacci(1)

이처럼 같은 연산이 계속 반복적으로 이용될 때, 메모이제이션을 활용하여 값을 미리 저장해두면 효율적
```

- 피보나치 구현에 재귀를 활용했다면 시간복잡도는 O(2^n)
- 동적 계획법을 활용하면 O(N)

## 🐌 4. 구현 방식

### Bottom-up

- 작은 문제부터 차근차근 구하는 방법
- 문제 해결에 용이
- 가독성이 떨어짐

```
// Bottom-Up 방식으로 작성한 피보나치 수열

int fibonacci(int n)
{
    dp[0] = 0, dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
}

```
### Top-Down

- 큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)
- 가독성이 좋음
- 코드 작성이 힘듦

```
// Top-Down 방식으로 작성한 피보나치 수열

int fibonacci(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
 
    if (dp[n] != -1) return dp[n];
 
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return dp[n];
}

```

### 동적계획법에는 뭐가 좋을까?

- 동적계획법으로 문제를 풀 때는 우선 작은 문제부터 해결해나가는 것이 좋음
- 작은 문제들을 풀어나가다보면 이전에 구해둔 더 작은 문제들이 활용되는 것을 확인하게 됨
- 이에 대한 규칙을 찾았을 때 점화식을 도출해내어 동적 계획법을 적용시키자!

---

##### 참고

- [동적 계획법(Dynamic Programming)](https://gyoogle.dev/blog/algorithm/Dynamic%20Programming.html)
