# :pushpin: 비트마스크(BitMask)

_집합의 요소들의 구성 여부를 표현할 때 유용한 기술_

:heavy_check_mark: 비트마스크를 사용하는 이유

- DP나 순열 등, 배열 활용만으로는 해결할 수 없는 문제
- 작은 메모리와 빠른 수행시간으로 해결이 가능
- 집합을 배열의 인덱스로 표현할 수 있음
- 간결한 코드
- 수의 범위가 너무 크면 사용할 수 없음!

:heavy_check_mark: 비트란?

- 컴퓨터에서 사용되는 데이터의 최소 단위

## :computer: 비트마스킹 활용

[1, 2, 3, 4, 5] 라는 집합이 있다고 가정

집합의 부분 집합을 확인할 때 비트마스킹을 사용하면 더 쉽게 표현 가능!

**집합의 i번째 요소가 존재하면 1, 그렇지 않으면 0**

- [1,2,3,4,5] -> 11111 -> 31
- [2,3,4,5] -> 11110 -> 30
- [1,2,5] -> 10011 -> 19
- [1] -> 00001 -> 1

**부분 집합을 배열이 아닌 정수로 표현할 수 있음!!!!!!!!!!**

## :computer: 비트 연산

_AND, OR, XOR, NOT, SHIFT_

- & (AND) : 대응하는 두 비트가 모두 1일 때 1 반환
- | (OR) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일 때, 1 반환
- ^ (XOR) : 대응하는 두 비트가 서로 다를 때, 1 반환
- ~ (NOT) : 비트 값 반전하여 반환
- \>\> , << (SHIFT) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환
  - 왼쪽 시프트 : 원래 숫자에서 2배가 됨
  - 오른쪽 시프트 : 원래 숫자에서 1/2배가 됨

## :computer: 비트마스킹 연산

:heavy_check_mark: 삽입

- i번째 비트를 1로 변경하고 싶을 때는 **OR 연산 활용**

  ```
  숫자 | 1 << i

  ex) 10101 | 1 << 3
  ```

:heavy_check_mark: 삭제

- i번째 비트를 0으로 변경하고 싶을 때는 **AND 연산과 NOT 연산 활용**

  ```
  숫자 & ~1 << i

  ex) 11101 & ~1 << 3
  ```

:heavy_check_mark: 조회

- i번째 비트가 무슨 값인지 알려면, **AND 연산 활용**

  ```
  숫자 & 1 << i

  ex) 10101 & 1 << 3
  ```

---

<br>

참고

- [비트마스크(BitMask)](https://gyoogle.dev/blog/algorithm/BitMask.html)
- [[코딩 테스트 준비 - 기초] 7. 비트마스크(Bitmask)](https://gyyeom.tistory.com/62)
