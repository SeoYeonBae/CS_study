## 💻 0. 객체 지향 프로그래밍

- OOP: Object-Oriented Programming
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만들고 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법

![image](https://user-images.githubusercontent.com/101535851/228233419-3a70364f-642c-4bff-b79c-68bc1855ed8f.png)


## 🏰 1. 객체란?

- 프로그램에서 사용되는 데이터 or 식별자에 의해 참조되는 공간
- 값을 저장할 변수 + 작업을 수행할 메소드를 서로 연관된 것들끼리 묶어서 만든 것
- 마치 레고와 같음 -> 레고 조각처럼 객체를 여러군데에서 재사용할 수 있음 (부품화, 재사용성이라는 특징)

## 🍀 2. 객체 지향 프로그래밍의 특징

### 🚙 1. 추상화

  - 객체에서 공통된 속성과 행위를 추출하는 것 = 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만드는 것
  - 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
  - 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것
  
  ![image](https://user-images.githubusercontent.com/101535851/228226231-5a5419f8-f683-4368-a0be-78e96df95e1d.png)
  > 아우디, 니싼, 볼보는 모두 자동차! 자동차라는 추상화 집합을 만들어두고 자동차들이 가진 공통적 특징들을 만들어서 활용

  - 추상화가 필요한 이유
    
    - 상기 예제에 현대라는 자동차 브랜드가 추가된다고 가정
    - 추상화로 자동차를 구현해놓으면 다른 곳의 코드를 수정할 필요 없이 추가로 만들 부분만 새로 생성

### 🍬 2. 캡슐화

  - 데이터 구조와 데이터를 다루는 방법들을 결합시켜 묶는 것 = 변수와 함수를 하나로 묶는 걸 뜻함
  - 낮은 결합도를 유지할 수 있도록 설계하는 것 = 한 곳에서 변화가 일어나도 다른 곳에 영향을 미치는 걸 최소화 시키는 것
  - 결합도가 낮아야 하는 이유?
    
    - 결합도란 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말
    - 즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요
    - 소프트웨어 공학에서는 객체 안의 모듈 간 요소가 밀접한 관련이 있는 것으로 구성해 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법이라고 배움

  ![image](https://user-images.githubusercontent.com/101535851/228227379-fdefd7dd-90b3-4e29-9c7f-12db4cc92715.png)

  - 속성과 기능을 정의하는 변수와 메소드를 클래스라는 캡슐에 넣어서 분류하는 것으로 재활용이 원활함
  - 캡슐화를 통해 어떻게 높은 응집도와 낮은 결합도를 갖게 하냐?
    
    - 바로 접근제어자의 활용
    - 외부에서 접근할 필요가 없는 애들은 ```private```으로 접근하지 못하도록 제한을 두는 것
    - 객체 안의 필드를 선언할 때 private으로 선언하는 것이 바로 이 때문!

### 👪 3. 상속

  - 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것을 의미함
  - 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능
  
  |장점|단점|
  |-|-|
  |재사용으로 인한 코드가 줄어든다|상위 클래스의 변경이 어려워진다|
  |범용적인 사용이 가능하다|불필요한 클래스가 증가할 수 있다|
  |자료와 메서드의 자유로운 사용 및 추가가 가능하다|상속이 잘못 사용될 수 있다|

### 🎥 4. 다형성

  - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
  - 하나의 클래스 내부에 같은 이름의 행위를 여러개 정의하거나 상위 클래스의 행위를 하위 클래스에서 재정의하여 사용 하는 것
  - 오버라이딩: 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용
  - 오버로딩: 같은 이름의 메소드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것

## 🙂 3. 객체 지향 프로그래밍의 장단점

### 1. 장점

  - 클래스 단위로 모듈화시켜서 개발하기 때문에 업무 분담이 편리하고 대규모 소프트웨어 개발에 적합하다.
  - 클래스 단위로 수정이 가능하기 때문에 유지 보수가 편리하다.
  - 클래스를 재사용하거나 상속을 통해 확장함으로써 코드 재사용이 용이하다.

### 2. 단점

  - 처리속도가 상대적으로 느리다.
  - 객체의 수가 많아짐에 따라 용량이 커질 수 있다.
  - 설계시 많은 시간과 노력이 필요하게 될 수 있다.

## 😮 4. 객체 지향 프로그래밍의 반대는 절차 지향 프로그래밍?

- 객체 지향 프로그래밍은 절차 지향 프로그래밍과 장단점이 겹치는 부분이 있기 때문에 그렇게 생각이 들 수는 있음
- 하지만! 절차지향은 순차적으로 실행에 초점이 되어있고 객체지향은 관계/조직에 초점을 맞추고 있다는 초점의 차이일 뿐!
- 절차적 프로그래밍이라고 해서 객체를 다루지 않는 것이 아니고, 객체지향 프로그래밍이라고해서 절차가 없는 것도 아님

## 🏗️ 객체 지향 설게 과정

  - 제공해야 할 기능을 찾고 세분화하고 그 기능을 알맞은 객체에 할당
  - 기능을 구현하는데 필요한 데이터를 객체에 추가
  - 그 데이터를 이용하는 기능을 넣음
  - 기능은 최대한 캡슐화하여 구현
  - 객체 간에 어떻게 메소드 요청을 주고받을 지 결정
  
## ✋ 6. 객체 지향 설계 원칙 SOLID

### 1. 단일 책임 원칙 (SRP, Single Responsibility Principle)

  - 하나의 클래스는 단 하나의 책임만 가져야 한다.
  - 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.

### 2. 개방-폐쇄 원칙 (OCP, Open/Closed Principle)

  - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.

### 3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

  - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

### 4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)

  - 범용 인터페이스 하나보다 클라이언트를 위한 여러 개의 인터페이스로 구성하는 것이 좋다.
  - 인터페이스는 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  - 클라이언트가 필요로 하는 인터페이스로 분리함으로써 각 클라이언트가 사용하지 않는 인터페이스에 변경이 있어도 영향을 받지 않도록 만들어야 한다.
  
### 5. 의존관계 역전 원칙 (DIP), Dependency Inversion Principle)

  - 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되고 저수준 모듈은 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

---

##### 참고

- [객체지향 프로그래밍](https://gyoogle.dev/blog/computer-science/software-engineering/Object-Oriented%20Programming.html)
- [객체지향 프로그래밍이란?](https://jongminfire.dev/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)
